  # 翻译|使用CRTP的一些优点
  
  使用CRTP有以下几个优点

 - Generic Code：作为一种泛型编程，使用CRTP的容器类，列表和数组的代码，程序会在编译器完成推导计算
  - Reusability：很容易地使用已有的代码去创建新的代码
  - Efficiency ：使用泛型编程的核心思想就是：对象、函数调用、它们的类型，甚至它们的值都是在编译时而不是运行时确定的，这与虚函数不同，虚函数需要编译器和操作系统生成的虚拟函数表的运行时开销。
  - Maintainability：因为总体上更少的代码量，因此可以更容易地维护代码。而不像在复杂的类层次结构中，多重继承关系导致的更多代码量。
  - Reliability: 知道代码适用于不同的类型，不用担心其内部实现
  - Readability: 代码的意图是显而易见的，而无需担心其内部结构。

因为其本身的复杂性，也会产生以下几个缺点

 - Syntax: 语法更加复杂，没有良好的编程习惯，很难正确地写出CRTP代码
 - Compiler: 根据编译器的实现不同，一些生成消息可能是晦涩难懂的，或者如果你没有真正了解编译器、生成的程序集以及幕后发生的事情，它可能会将你指向到错误的代码行，而不是实际产生或调用错误的代码行
 - Linker: 只要代码编译和对象链接正确，链接器就不应该有任何问题。
 - Debugger: 同Compiler类似，调试时的生成信息也是晦涩难懂的，可能将开发者导向错误的代码位置，而不是真正产生或触发Error和异常的位置
 - Readability: 因为所需语法的复杂性，阅读起来会有一点困难


至于使用哪种编程范式（该语境下，主要是指CRTP和OOP）才是最佳的实践方式，需要取决于你的代码所面向的目标来权衡差异。

- 如果你需要快速和有效率的代码并且可轻松地复用，同时以最小的开销去实现。那么CRTP是更好的选择
- 如果您需要一个更强的OOP代码库，它利用的类层次结构，具有继承性、多态性、动态和堆内存的，那么使用OOP范式的代码库将是合适的。

当然，一个单独代码库是可以同时使用两种范式去编程的，各取其长处来集成到你的程序中。因此，我们更需要了解的是何时何地去使用每一种类型。

这是查看代码设计实践的正确方法的一个主要示例：我将使用简单的 3D 图形引擎的想法来说明这种思考、规划和开发的方法

- 使用CRTP来创建泛型，可复用，高效的容器，迭代器和算法，并且在编译期生成，用于存储自定义对象并对其进行操作
- 使用类层次结构来创建您的自定义对象、类、结构等，您将在整个代码库中使用这些对象、类和结构。


- - -

在3D游戏引擎里，你可能需要几个容器类来存储游戏所有的资产，比如作为纹理使用的图像文件，字体，精灵，模型，shaders，音频等以及其他更多的类型。这些类型的类管理着加载、读取和解析这些文件的功能，并将其信息转换为开发者提供的自定义数据结构，它们的核心是CRTP，但它们仍然可以共享继承的概念。

例如，单独的管理器类本身将以CRTP方式设计，以处理自定义对象的所有文件加载、创建、存储和内存清理，但它们中的大部分本身可以继承自Singleton基类对象，该对象可能需要也可能不需要子类具有虚拟函数。类层次结构可能如下所示

- Singleton - 必须从中继承的抽象基类，它的每个派生类型在每次应用程序运行时只会构造一次。以下所有类都是从Singleton派生的。
    - AssetManager - 管理内部存储对象的存储和清理，这些对象可以是纹理、字体、gui、模型、着色器或音频文件
    - AudioManager - 管理音频播放的所有
    - TextureManager - 管理不同的，已加载纹理的实例计数，防止不必要的重复打开、读取和加载多个类型的单个文件，并防止生成和存储同一对象的多个副本
    - FontManager - 管理所有的字体资产，类似于TextureManager，但专为处理字体而设计
    - SpriteManager - 根据引擎和游戏类型的不同，精灵可以使用也可以不使用，或者通常可以被视为一种特点类型的纹理
    - ShaderManager - 管理所有用于在游戏帧或场景中，实现光照和着色的Shader文件
    - GuiManager - 处理引擎支持的所有图形用户界面类型的对象，如按钮、单选按钮、滑块、列表框、复选框、文本字段、宏框等。。。
    - AnimationManager - 将处理和存储引擎将支持的所有对象动画。
    - TerrainManager - 负责所有游戏的地形信息，从顶点和法线数据到高度图、凹凸图等，到彩色或图案纹理，再到与地形相关的各种着色器，这些着色器还可以包括skybox或skydome、云、太阳或月亮以及背景信息。也可能包括诸如鹅肝草、树木、灌木等物体。。。
    - ModelManager - 管理为对象生成必要三维网格的所有三维模型信息，还处理其他内部数据，如纹理坐标、索引坐标和法线坐标等

正如您从上面看到的，这些管理器类中的每一个都将使用CRTP进行设计，因为它提供了一种创建通用结构的方法，可以处理许多不同类型的对象。然而，整个类层次结构仍然使用继承，并且可能需要也可能不需要虚拟方法。后者取决于您的需求或意图。如果您希望其他人重用您的Singleton类来实现他们自己的个人类型的管理器或其他Singleton的类，如Logger和/或ExceptionHandler，那么您可能希望他们必须实现初始化和清理功能。

现在，对于你的游戏中对象，比如你的类中使用的模型，甚至抽象的GameplayObject比如玩家和敌人，他们将从通用角色类继承。这些将生成一个类层次结构，根据特定需求，可能需要使用虚拟方法，也可能不需要使用CRTP范式。

这是为了演示何时、何地以及如何正确使用这些范式。

如果你想了解两者的性能有何不同，你最终可以写两个代码库来执行相同的任务，一个专门用CRTP创建，另一个不使用CRTP，只使用继承和虚拟函数。然后将这些代码库输入到各种在线编译器中，这些编译器将为可使用的各种类型的可用编译器生成不同类型的汇编指令，并比较生成的汇编。我喜欢Jason Turn使用的编译器资源管理器

---

下面的评论提到了一条关于CRTP的潜在缺点：  
>CRTP的一个缺点是，当应用静态强制转换时，不能将方法定义为const。这意味着这些非const方法，对于使用CRTP实现接口的const对象将不可见
